import operator
import configParser
import sys, logging
import dialog

"""
The DecisionMaker class is responsible for deciding the best answer to give to the user. 

It receives the answers generated by the AgentManager and DefaultAnswers modules, and based on a formally defined decision strategy, the DecisionMaker chooses one of those answers to be delivered to the user.

The current available decision strategies are:
    SimpleMajority: Given a set of agent answers, delivers the most frequent answer to the user
"""


class DecisionMaker:
    """
    __init__: Initialize the DecisionMaker object
    - Receives the desired decision method when the object is instantiated in SaySomethingSmart.py
    - The decision method can be configured through the parameter <decisionMethod> in the config.xml
    """
    def __init__(self,decisionMethod):
        self.decisionMethod = decisionMethod



    """
    decideBestAnswer(self, defaultAgentsAnswers, externalAgentsAnswers): Upon receiving the answers from all available agents, decides the best answer to be delivered to the user
    
    defaultAgentsAnswers: Dictionary containing the answers of the default SSS agents in the format {'evaluator1': 'answer1', 'evaluator2': 'answer2'}
    externalAgentsAnswers: Dictionary containing the answers of all available external agents in the format {'agent1': 'answer1', 'agent2': 'answer2'}

    If the chosen decision method is the SimpleMajority, the process goes as:
        - Create an answerFrequency dictionary in order to determine the most frequent answer
            - Key (String): Answer string of an agent
            - Value (int): Number of times that particular answer has been given by an answer
        - Merge the dictionaries corresponding to the answers of both defaultAgents and externalAgents
        - For each agent's answer, update the answerFrequency dictionary (add 1 to the number of times that answer appeared)
        
    If the chosen decision method is the PrioritySystem, the process is as follows:
        - Merge the dictionaries corresponding to the answers of both defaultAgents and externalAgents
        - Obtain the priorities dictionary from the config.xml file. 
            Given a file sample such as:
                <prioritySettings>
                  <agent name="Agent1" priority="1" />
                  <agent name="Agent2" priority="2" />
                </prioritySettings>
            A dictionary will be created with the format {"Agent1": 1, "Agent2": 2}
        - When the first agent's answer is found, a tuple (answer, priority) is stored
        - If the agent is not listed in the priority settings (on the config.xml), its priority is set as sys.maxsize
        - For each agent's answer, the system verifies if that agent has a higher priority than the current stored answer; if the agent's priority is higher, then the answer is replaced
        - If a higher-priority agent doesn't give a valid answer, then the second-highest priority agent is checked, and so on



    Return finalAnswer string corresponding to the answer to be delivered to the user

    Sidenote: If none of the agents gave an answer, the default failure message is delivered (this message can be configured through the parameter <noAnswerFound> in the config.xml)
    """    
    def decideBestAnswer(self,defaultAgentsAnswers,externalAgentsAnswers):
        
        if(self.decisionMethod == "SimpleMajority"):

            answerFrequency = {}

            mergedAgentAnswers = {**defaultAgentsAnswers, **externalAgentsAnswers}

            try:
                for agent in mergedAgentAnswers.keys():

                    if(type(mergedAgentAnswers[agent]) is list):
                        mergedAgentAnswers[agent] = mergedAgentAnswers[agent][0]

                    answer = mergedAgentAnswers[agent]

                    if(type(answer) is dialog.SimpleQA.SimpleQA):
                        answer = answer.getAnswer()

                    answerFrequency[answer] = answerFrequency.get(answer,0) + 1
                    print('Answer from agent ' + agent + ': \n' + answer + '\n')            


                finalAnswer = max(answerFrequency.items(),key=operator.itemgetter(1))[0]

                return finalAnswer
            
            except ValueError:
                return configParser.getNoAnswerMessage()


        elif(self.decisionMethod == "PrioritySystem"):

            mergedAgentAnswers = {**defaultAgentsAnswers, **externalAgentsAnswers}
            priorities = configParser.getPriorities()

            finalAnswer = ""
            answerFrequency = {}


            for agent in mergedAgentAnswers.keys():
                
                logging.info('Answer from agent ' + agent + ': \n' + mergedAgentAnswers[agent] + '\n')
                print('Answer from agent ' + agent + ': \n' + mergedAgentAnswers[agent] + '\n')
                
                if(finalAnswer == ""):
                    finalAnswer = (mergedAgentAnswers[agent],getPriority(agent,priorities))
                    answerFrequency[mergedAgentAnswers[agent]] = answerFrequency.get(mergedAgentAnswers[agent],0) + 1
                else:
                    if(getPriority(agent,priorities) < finalAnswer[1] and mergedAgentAnswers[agent] != configParser.getNoAnswerMessage()):
                        finalAnswer = (mergedAgentAnswers[agent],getPriority(agent,priorities))
                    else:
                        answerFrequency[mergedAgentAnswers[agent]] = answerFrequency.get(mergedAgentAnswers[agent],0) + 1
            if(finalAnswer[1] == sys.maxsize):
                return max(answerFrequency.items(),key=operator.itemgetter(1))[0]
            return finalAnswer[0]




        elif(self.decisionMethod == "AgentMultiAnswers"):
            
            
            answerFrequency = {}

            mergedAgentAnswers = {**defaultAgentsAnswers, **externalAgentsAnswers}

            try:
                for agent in mergedAgentAnswers.keys():
                    if(type(mergedAgentAnswers[agent]) is str):
                        mergedAgentAnswers[agent] = [mergedAgentAnswers[agent]]

                    print('Answers from agent ' + agent + ':')

                    for answer in mergedAgentAnswers[agent]:
                        if(type(answer) is dialog.SimpleQA.SimpleQA):
                            answer = answer.getAnswer()
                        answerFrequency[answer] = answerFrequency.get(answer,0) + 1/len(mergedAgentAnswers[agent])
                        print(answer)


                finalAnswer = max(answerFrequency.items(),key=operator.itemgetter(1))[0]

                return finalAnswer
            
            except ValueError:
                return configParser.getNoAnswerMessage()





        elif(self.decisionMethod == "PrioritySystemMultiAnswers"):

            mergedAgentAnswers = {**defaultAgentsAnswers, **externalAgentsAnswers}
            priorities = configParser.getPriorities()

            finalAnswer = ""
            answerFrequency = {}


            for agent in mergedAgentAnswers.keys():
                
                if(type(mergedAgentAnswers[agent]) is str):
                    mergedAgentAnswers[agent] = [mergedAgentAnswers[agent]]

                logging.info('Answers from agent ' + agent + ':')
                print('Answers from agent ' + agent + ':')
                
                for answer in mergedAgentAnswers[agent]:
                    if(type(answer) is dialog.SimpleQA.SimpleQA):
                        answer = answer.getAnswer()

                    if(finalAnswer == ""):
                        if(answer != configParser.getNoAnswerMessage()):
                            finalAnswer = (answer,getPriority(agent,priorities))
                            answerFrequency[answer] = answerFrequency.get(answer,0) + 1
                        else:
                            break
                    else:
                        if(getPriority(agent,priorities) < finalAnswer[1] and answer != configParser.getNoAnswerMessage()):
                            finalAnswer = (answer,getPriority(agent,priorities))
                        else:
                            answerFrequency[answer] = answerFrequency.get(answer,0) + 1
                    logging.info(answer)
                    print(answer)
                
                logging.info('\n')
                print()

            if(finalAnswer == ""):
                return configParser.getNoAnswerMessage()
            elif(finalAnswer[1] == sys.maxsize):
                return max(answerFrequency.items(),key=operator.itemgetter(1))[0]
            return finalAnswer[0]



        elif(self.decisionMethod == "PrioritySystemDevelopmentMulti"):

            mergedAgentAnswers = {**defaultAgentsAnswers, **externalAgentsAnswers}
            priorities = configParser.getPriorities()

            finalAnswer = ""
            answerFrequency = {}


            for agent in mergedAgentAnswers.keys():
                
                if(type(mergedAgentAnswers[agent]) is str):
                    mergedAgentAnswers[agent] = [mergedAgentAnswers[agent]]

                logging.info('Answers from agent ' + agent + ':')
                print('Answers from agent ' + agent + ':')
                
                for answer in mergedAgentAnswers[agent]:
                    if(type(answer) is dialog.SimpleQA.SimpleQA):
                        answer = answer.getAnswer()

                    if(finalAnswer == ""):
                        if(answer != configParser.getNoAnswerMessage()):
                            finalAnswer = [(answer,getPriority(agent,priorities))]
                            answerFrequency[answer] = answerFrequency.get(answer,0) + 1
                        else:
                            break
                    else:
                        if(getPriority(agent,priorities) < finalAnswer[0][1] and answer != configParser.getNoAnswerMessage()):
                            finalAnswer = [(answer,getPriority(agent,priorities))]
                        elif(getPriority(agent,priorities) == finalAnswer[0][1] and answer != configParser.getNoAnswerMessage() and (answer,getPriority(agent,priorities)) not in finalAnswer):
                            finalAnswer.append((answer,getPriority(agent,priorities)))
                        else:
                            answerFrequency[answer] = answerFrequency.get(answer,0) + 1
                    logging.info(answer)
                    print(answer)
                
                logging.info('\n')

            if(finalAnswer == ""):
                return configParser.getNoAnswerMessage()
            elif(finalAnswer[0][1] == sys.maxsize):
                if(configParser.getAnswerAmount() > 1):
                    compositeAnswer = ""
                    answerItems = sorted(answerFrequency.items(),key=operator.itemgetter(1),reverse=True)
                    i = 0
                    while(i < len(answerItems) and i < configParser.getAnswerAmount()):
                        compositeAnswer += str(i + 1) + ": " + answerItems[i][0] + "\n"
                        i += 1
                    return compositeAnswer
                return max(answerFrequency.items(),key=operator.itemgetter(1))[0]
            else:
                if(configParser.getAnswerAmount() > 1):
                    compositeAnswer = ""
                    answerItems = finalAnswer
                    i = 0
                    while(i < len(answerItems) and i < configParser.getAnswerAmount()):
                        compositeAnswer += str(i + 1) + ": " + answerItems[i][0] + "\n"
                        i += 1
                    return compositeAnswer

                return finalAnswer[0][0]
        



def getPriority(agent, priorityDoc):

    if(agent in priorityDoc.keys()):
        return priorityDoc[agent]
    else:
        return sys.maxsize
