# Say Something Smart

## What is it?

Say Something Smart (SSS) is a dialogue engine based on a large corpus of movie subtitles (Subtle). 

This specific branch is focused on the implementation of a plug-and-play system composed by multiple distinct agents: each agent gives its own response to the received user input, and the best answer is reached through a formally estabilished consensus strategy.


## How does it work?

Upon receiving input from the user, SSS retrieves the most similar candidates (that is, entries of the Subtle corpus) through Lucene and sends both the user query and the Lucene candidates to all available agents. Subsequently, each agent gives its own answer to the query, and the best answer is delivered to the user.

This process is accomplished through the use of four modules: 
- The `LuceneWrapper` module, which indexes the Subtle corpus and allows the other SSS modules to retrieve the best candidates to a query.
- The `DefaultAnswers` module, which, given a user query, generates the answers of the default SSS agents to that query.
- The `AgentManager` module, which initializes all of the external agents and, upon receiving a user query, delivers the necessary information (query, Lucene candidates) to each external agent. It also stores the answers of each external agent.
- The `DecisionMaker` module, which receives the answers generated by the DefaultAnswers and AgentManager modules, and based on a voting strategy, decides the best answer to give to the user. It will also be the module that manages the weight each agent has on the final answer.



---
# Getting Started

### **Requirements:**
- [Python 3](https://www.python.org/downloads/)
- [Java Development Kit](https://www.oracle.com/technetwork/java/javase/downloads/index.html)
- [Lucene's binary release](https://lucene.apache.org/core/downloads.html)

Extract Lucene's binary release (preferentially to the same folder where pySSS is located) and install nltk through the command:

    pip3 install nltk

Open your `setup.sh` file (which should be located inside the pySSS folder) and edit the following variables:
- `LUCENE_DIR` corresponds to the directory where the binary release of Lucene was extracted.
- `LUCENE_VERSION` is the version of your Lucene release.
- `DB4O_DIR` is the directory where the file `db4o-8.0.249.16098-core-java5.jar` is located (it should correspond to the path pointing to this repository).

For example:

    LUCENE_DIR=/home/hawke/Work/SSS-python/lucene-7.7.1
    LUCENE_VERSION=7.7.1
    DB4O_DIR=/home/hawke/Work/SSS-python/

The rest of the script content should be kept intact, as not to break the building process.

Afterwards, run `setup.sh` through the following command (note that you should only have to run it in your first time building the project):

    . setup.sh

Finally, to try out running SSS, execute the command:

    python3 SaySomethingSmart.py

The program should prompt you to *"Say something:"*. Once it does, type your query (for example, *"Como te chamas?"*), and hit Enter. The answers from each agent should appear on the screen, along with SSS's final answer.

When you're done with interacting, type `exit` to terminate the program.

---
# How-To: Create New Agents

An external agent, in the context of SSS, is defined by two components: the configuration file, and the source code.

The configuration file serves as the "header" of the agent for SSS: it allows the agent to be detected and added to the pool of available agents, and it also allows the user to set configurable parameters without directly interacting with the source code. Each agent has its own configuration file.

The source code of the agent is composed by one or more source files, which have the goal of delivering an answer upon receiving a user query (and, optionally, a set of Lucene candidates).


## 1. Paths and Directories

Before you start building your new agent, you should know where it should be placed in order to be found by SSS.

For the context of building agents, the folder structure of SSS is as follows:

    pySSS
    └── resources
        └── externalAgents
            ├── AgentFactory.py
            ├── Agent1
            │   ├── config.xml
            │   └── Agent1.py
            └── Agent2
                ├── config.xml
                └── Agent2.py

When creating a new agent, the directory containing the source code and config file of the agent should be inside the `externalAgents` folder, and the configuration file of the agent **must** be named `config.xml`.

To start off, let's create a new folder inside `externalAgents` called `SimplestAgent`, which will be our `HelloWorld` for this tutorial.

## 2. Source Code

As mentioned before, an agent can have more than one source file, but it must have a **main** source file. The main file usually has the same name as the agent's folder, and it corresponds to the connection point between SSS and the agent.

That said, the following indications must be followed when creating a new agent:

- The agent's main file must be implemented as a `class`;
- The agent's class must implement the function `requestAnswer(self,userInput,candidates)`, which receives a `userInput` string and a `candidates` array, and must return an `answer` string.

To give a simple example, if we wanted to implement an agent that always delivered the same answer to the user regardless of the input or the candidates, we could create a file called `SimplestAgent.py` inside the `SimplestAgent` directory that contained the following code:

    class SimplestAgent:
        def requestAnswer(self,userInput,candidates):
           return "This is a very good answer!"
    

When SSS requests the answer of each agent, it does so by calling the function `agent.requestAnswer(userInput,candidates)`, and expects to receive a string corresponding to the agent's answer to the userInput in return.

- `userInput` is a string that contains a query made directly to SSS by the user (e.g.: "Como te chamas?").
- `candidates` is an array containing the generated Lucene candidates for the above user query in the format `[CandidateObject1, CandidateObject2, ... , CandidateObjectN]`. Candidate objects correspond to instances of the `SimpleQA` class, found in:

        pySSS
        └── dialog
            ├── BasicQA.py
            └── SimpleQA.py

Building agents that use the provided Lucene candidates is explored in a further section of this guide.


## 3. Configuration File

To create and interact with each individual agent, the `AgentManager` searches for all `config.xml` files inside the `externalAgents` directory and subdirectories. In order to be found by the `AgentManager`, each agent has a configuration file where its configurable parameters are defined.

When creating the `config.xml` file for your agent, you should follow the structure below:

    <config>
        <mainClass>agentName</mainClass>
        (other parameters to define)
        (...)
    </config>

All defined parameters must be encapsulated by the exterior tag `<config>`, and the `<mainClass>`must be defined with the same name as the main class of the agent.

For example, in the case of our `SimplestAgent` presented earlier, the `config.xml` would be located inside the `SimplestAgent` folder and contain something like this:

    <config>
        <mainClass>SimplestAgent</mainClass>
    </config>

When this configuration file is parsed by the `AgentManager`, a `configs` dictionary will be generated in the format `{'mainClass': 'SimplestAgent'}`, which can subsequently be passed to the agent class.


## 4. Agent Factory

Finally, after having created our source code and configuration files, we have to tell the `AgentManager` what it should do when it detects our new agent. For that purpose, an auxiliary source file named `AgentFactory.py` is included in the `externalAgents` folder.

We have to make two additions for our agent to be detected:

- Add an import statement to the beginning of the file, pointing to the new agent's class.
- Add a condition in the `agentHandler(configs)` function in order to create a new instance of our agent.

At this point, the `configs` object provided by the function as a parameter is already populated by the data in your `config.xml` file as described in the end of step 3, and you can pass it along to your agent if you wish to.

In the case of our `SimplestAgent`, after concluding the previous steps, our current directory structure should look similar to the following:

    pySSS
    └── resources
        └── externalAgents
            ├── AgentFactory.py
            └── SimplestAgent
                ├── config.xml
                └── SimplestAgent.py

As such, we will add the following `import` statement to the beginning of `AgentFactory.py` in order to gain access to the `SimplestAgent` class:

    from .SimplestAgent.SimplestAgent import SimplestAgent

And we will also add the following condition to the end of the `agentHandler(configs)` function:

    elif(mainClass == 'SimplestAgent'):
        return SimplestAgent()

That is, upon detecting a `config.xml` file with `SimplestAgent` defined as the `mainClass` parameter, it will return a new instance of the `SimplestAgent` class.


## 5. Conclusion

So far, we have covered the basics of adding a new agent to our system. If you followed the steps for the creation of the `SimplestAgent`, upon running SaySomethingSmart again and making a query, you should notice that the agent is already interacting with the system.

    Answer from agent SimplestAgent: 
    This is a very good answer!

In the following sections, we will cover how to make use of the Lucene candidates and explore the implementation details of SSS's architecture further.